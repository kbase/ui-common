define(['nunjucks', 'jquery', 'q', 'json!functional-site/config.json'], 
function (nunjucks, $, Q, config) {
    "use strict";

    var SocialWidget = Object.create({}, {

        // The init function interfaces this object with the caller, and sets up any 
        // constants and constant state.
        SocialWidget_init: {
            value: function (cfg) {                
                this._generatedId = 0; 
                
                // First we get the global config.
                this.globalConfig = config[config.setup];  
                this.localConfig = {}; 
                
                // Core to any widget is that it attaches somewhere in the DOM.
                // The widget requires a container to attach content to
                if (!cfg.container) {
                  throw 'A container is required by this Widget, but was not provided.';
                }
                this.container = cfg.container;
                if (typeof this.container === 'string') {
                    this.container = $(this.container);
                }   
                
                // PARAMS          
                // The params object is used to hold any parameterized input.
                this.params = {};
                
                // Also the userId is required -- this is the user for whom the social widget is concerning.
                this.params.userId = cfg.userId;

                // OTHER CONFIG
                // The widget requires a name to use for various purposes.
                if (!cfg.name) {
                  throw 'Widget name is required';
                }
                this.widgetName = cfg.name;
                
                if (!cfg.title) {
                  throw 'Widget title is required';
                }
                this.widgetTitle = cfg.title;

                this.messages = [];

                // Auth State
                this.syncAuth();
                
                // The state object is used to hold any data generated by this 
                // widget.
                // It is merged onto the context object prior to rendering.
                this.state = {};
                
                // Set up the templating system.
                // NB the templating requires a dedicated widget resources directory in 
                //   /src/widgets/WIDGETNAME/templates
                this.templates = {};
                this.templates.env = new nunjucks.Environment(new nunjucks.WebLoader('/src/widgets/social/'+this.widgetName+'/templates'), {
                    'autoescape': false
                });
                this.templates.env.addFilter('kbmarkup', function(s) {
                  if (s) {
                    s = s.replace(/\n/g, '<br>');
                  }
                  return s;
                });
                // This is the cache of templates.
                this.templates.cache = {};

                // The context object is what is given to templates.
                this.context = {};
                this.context.env = {
                    loggedIn: this.isLoggedIn(),
                    widgetTitle: this.widgetTitle,
                    widgetName: this.widgetName
                };
                // NB this means that when clearing state or params, the object
                // should not be blown away.
                this.context.state = this.state;
                this.context.params = this.params;


                // Set up listeners for any kbase events we are interested in:
                // NB: following tradition, the auth listeners are namespaced for kbase; the events
                // are not actually emitted in the kbase namespace.
                $(document).on('loggedIn.kbase', function(e, auth) {
                   this.onLoggedIn(e, auth);
                }.bind(this));

                $(document).on('loggedOut.kbase', function(e, auth) {
                    this.onLoggedOut(e, auth);
                }.bind(this));

                return this;
            }
        },
        
        syncApp: {
          value: function () {
            return;
          }
        },
        
        syncAuth: {
          value: function () {
            var loginWidget = $('<div></div>').kbaseLogin();
            this.auth = {
              authToken: loginWidget.get_session_prop('token'), 
              userId: loginWidget.get_session_prop('user_id'),
              username: loginWidget.get_session_prop('user_id'),
              realname: loginWidget.get_session_prop('name')
            }
          }
        },
        
        // LIFECYCLE
        
        start: {
            value: function () {
                this.loadCSS();
                this.renderLayout();
                this.renderWaitingView();
                this.recalcState();
            }
        },

        stop: {
            value: function () {
              // ???
            }
        },
        
        destroy: {
          value: function () {
            // tear down any events, etc. that are not attached
            // to the local container.
          }
        },
        
        // CONFIG
        getConfig: {
          value: function (key, defaultValue) {
            if (this.localConfig[key] !== undefined) {
              return this.localConfig[key];
            } else if (this.globalConfig[key] !== undefined) {
              return this.globalConfig[key];
            } else {
              return defaultValue;
            }
          }
        },
        
        hasConfig: {
          value: function (key) {
            if (this.localConfig[key] !== undefined &&
                this.globalConfig[key] !== undefined) {
                  return false;
            } else {
              return true
            }
          }
        },
        
     
        setProp: {
          value: function (path, object, value) {
            
            if (typeof path === 'string') {
              path = path.split('.');
            }
            
            var key = path.pop();
            
            for (var i=0; i<path.length; i++) {
              if (object[path] === undefined) {
                object[path] = {};
              }
              object = object[path];
            }
            
            object[key] = value;
          }
        },
        
        // PARAMETERS
        // Parameters are typically passed into the init() method, and represent external values that vary for each 
        // new object. Typical use cases are url query variables.
        setParam: {
          value: function (path, value) {
            this.setProp(path, this.params, value);
            this.refresh();            
          }
        },
        
        
        recalcState: {
          value: function() {
            var widget = this;
            this.getCurrentState()
            .then(function () {
              widget.refresh();
            })
            .catch(function (err) {
              widget.renderErrorView(err);
            })
            .done();
            /*
            this.getCurrentState({
              success: function() {
                this.refresh();
              }.bind(this),
              error: function (err) {
                this.renderErrorView(err);
              }.bind(this)
            });
            */
          }
        },
        
        refresh: {
          value: function () {
            if (!this.refreshTimer) {              
              this.refreshTimer = window.setTimeout(function () {
                this.refreshTimer = null;
                this.render();
              }.bind(this), 0);
            }
          }
        },
        

        // STATE CHANGES

        /*
        getCurrentState
        This should do prepare the internal state to the point at
        which rendering can occur. It will typically fetch all data and stache it, 
        and perhaps perform some rudimentary analysis.
        */
        setState: {
          value: function (path, value) {
            this.setProp(path, this.state, value);
            this.refresh();
          }
        },
        
        to_promise: {
          value: function(client, method, arg1) {
            var def = Q.defer();
            client[method](arg1,
            function(result) {
              def.resolve(result);
            }, 
            function (err) {
              def.reject(err);
            });
            return def.promise;
          }
        },
        promise: {
          value: function(client, method, arg1) {
            var def = Q.defer();
            client[method](arg1,
            function(result) {
              def.resolve(result);
            }, 
            function (err) {
              def.reject(err);
            });
            return def.promise;
          }
        },
        
        getCurrentState: {
            value: function (options) {
              // set the state here.
              var def = Q.defer();
              def.resolve();
              return def.promise;
              //options.success();
              // return this;
            }
        },
        
        // EVENT HANDLERS

        onLoggedIn: {
            value: function (e, auth) {
                this.syncAuth();
                  // this.auth.authToken = auth.token;
                this.syncApp();
                this.recalcState();
            }
        },
        
        onLoggedOut: {
            value: function (e, auth) {
                //this.auth.authToken = null;
                this.syncAuth();
                this.syncApp();
                this.recalcState();
            }
        },
        
        // STATE CALCULATIONS
        
        isLoggedIn: {
          value: function () {
            if (this.auth.authToken) {
              return true;
            } else {
              return false;
            }
          }
        },

        // TEMPLATES
        getTemplate: {
            value: function(name) {
                if (this.templates.cache[name] === undefined) {
                    this.templates.cache[name] = this.templates.env.getTemplate(name + '.html');
                }
                return this.templates.cache[name];
            }
        },
        
        createTemplateContext: {
          value: function () {
            /*
            var context = this.merge({}, this.context);
            return this.merge(context, {
              state: this.state, 
              params: this.params
            })
            */
            
            return this.context;
          }
        },
        
        renderTemplate: {
            value: function(name, context) {
                var template = this.getTemplate(name);
                if (!template) {
                  throw 'Template ' + name + ' not found';
                }
                var context = context ? context : this.createTemplateContext();
                return template.render(context);
            }
        },
       
        // Generates a unique id for usage on synthesized dom elements.
        genId: {
            value: function() {
                return 'gen_' + this.widgetName + '_' + this._generatedId++;
            }
        },
        
        renderErrorView: {
        	value: function (error) {
            // Very simple error view.
            this.context.error = error;
				    this.places.content.html(this.getTemplate('error').render(this.context));
        	}
        },
        
        niceElapsedTime: {
          value: function (dateString) {
            // need to strip off the timezone from the string.
            var isoRE = /(\d\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)([\+\-])(\d\d\d\d)/;
            var dateParts = isoRE.exec(dateString);
            if (!dateParts) {
              return '** Invalid Date Format **';
            } else if (dateParts[8] !== '0000') {
              return '** Invalid Date TZ Offset ' + dateParts[8] + ' **';
            }
            
            var newDateString = dateParts[1]+'-'+dateParts[2]+'-'+dateParts[3]+'T'+dateParts[4]+':'+dateParts[5]+':'+dateParts[6];
            
    				var d = new Date(newDateString);
    				var shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            
    				var time = "";
    				var minutes = d.getMinutes();
    				if (minutes < 10) {
    					minutes = "0" + minutes;
    				}
    				if (d.getHours() >= 12) {
    					if (d.getHours() != 12) {
    						time = (d.getHours() - 12) + ":" + minutes + "pm";
    					} else {
    						time = "12:" + minutes + "pm";
    					}
    				} else {
    					time = d.getHours() + ":" + minutes + "am";
    				}
    				return shortMonths[d.getMonth()] + " " + d.getDate() + ", " + d.getFullYear() + " at " + time;
          }
        },
        
        merge: {
          value: function (objA, objB) {
            var Merger = {
                init: function(obj) {
                    this.dest = obj;
                    return this;
                },
                getType: function(x) {
                    var t = typeof x;
                    if (t === 'object') {
                        if (x === null) {
                            return 'null';
                        } else if (x.pop && x.push) {
                            return 'array';
                        } else {
                            return 'object';
                        }
                    } else {
                        return t;
                    }
                },
                merge: function(dest, obj) {
                    this.dest = dest;
                    switch (this.getType(obj)) {
                        case 'string':
                        case 'integer':
                        case 'boolean':
                        case 'null':
                            throw "Can't merge a '" + (typeof val) + "'";
                            break;
                        case 'object':
                            return this.mergeObject(obj);
                            break;
                        case 'array':
                            return this.mergeArray(obj);
                            break;
                        default:
                            throw "Can't merge a '" + (typeof val) + "'";
                    }

                },
                mergeObject: function(obj) {
                    var keys = Object.keys(obj);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var val = obj[key];
                        var t = this.getType(val);
                        switch (t) {
                            case 'string':
                            case 'number':
                            case 'boolean':
                            case 'null':
                                this.dest[key] = val;
                                break;
                            case 'object':
                                if (!this.dest[key]) {
                                    this.dest[key] = {};
                                }
                                this.dest[key] = Object.create(Merger).init(this.dest[key]).mergeObject(obj[key]);
                                break;
                            case 'array':
                                if (!this.dest[key]) {
                                    this.dest[key] = [];
                                } else {
                                    this.dest[key] = [];
                                }
                                this.dest[key] = Object.create(Merger).init(this.dest[key]).mergeArray(obj[key]);
                                break;
                            case 'undefined':
                                if (this.dest[key]) {
                                    delete this.dest[key];
                                }
                                break;
                        }
                    }
                    return this.dest;
                },
                mergeArray: function(arr) {
                    var deleted = false;
                    for (var i = 0; i < arr.length; i++) {
                        var val = arr[i];
                        var t = this.getType(val);
                        switch (t) {
                            case 'string':
                            case 'number':
                            case 'boolean':
                            case 'null':
                                this.dest[i] = val;
                                break;
                            case 'object':
                                if (!this.dest[i]) {
                                    this.dest[i] = {};
                                }
                                this.dest[i] = Object.create(Merger).init(this.dest[i]).mergeObject(arr[i]);
                                break;
                            case 'array':
                                if (!this.dest[i]) {
                                    this.dest[i] = [];
                                }
                                this.dest[i] = Object.create(Merger).init(this.dest[i]).mergeArray(obj[i]);
                                break;
                            case 'undefined':
                                if (this.dest[i]) {
                                    this.dest[i] = undefined;
                                }
                                break;
                        }
                    }
                    if (deleted) {
                        return this.dest.filter(function(value) {
                            if (value === undefined) {
                                return false;
                            } else {
                                return true;
                            }
                        });
                    } else {
                        return this.dest;
                    }
                }
            };
            return Object.create(Merger).merge(objA, objB);
          }
        },
        
        getProp: {
            value: function(obj, prop) {
                var props = prop.split('.');

                var temp = obj;
                for (var i = 0; i < props.length; i++) {
                    var key = props[i];
                    if (temp[key] === undefined) {
                        return obj[key];
                    } else {
                        temp = temp[key];
                    }
                }
                return temp;
            }
        },
        
        isBlank: {
            value: function(value) {
                if (value === undefined) {
                    return true;
                } else if (typeof value === 'object') {
                    if (value === null) {
                        return true;
                    } else if (value.push && value.pop) {
                        if (value.length === 0) {
                            return true;
                        }
                    } else {
                        if (value.getOwnPropertyNames().length === 0) {
                            return true;
                        }
                    }
                } else if (typeof value === 'string' && value.length === 0) {
                    return true;
                }
                return false;
            }
        },
        

        // DOM UPDATE

        // An example universal renderer, which inspects the state of the widget and
        // displays the appropriate content.
        render: {
            value: function () {
                // Generate initial view based on the current state of this widget.
                // Head off at the pass -- if not logged in, can't show profile.
                if (this.isLoggedIn()) {
                    this.places.title.html(this.widgetTitle);
                    this.places.content.html(this.renderTemplate('authorized'));
                } else {
                    // no profile, no basic aaccount info
                    this.places.title.html(this.widgetTitle);
                    this.places.content.html(this.renderTemplate('unauthorized'));
                }
                return this;
            }
        },
        
        // These are some very basic renderers for common functions. 

        // This can provide an initial layout, such as a panel, and provide container nodes,
        // such as title and content.
        renderLayout: {
            value: function() {
                this.container.html(this.getTemplate('layout').render(this.context));
                this.places = {
                	title: this.container.find('[data-placeholder="title"]'),
                  alert: this.container.find('[data-placeholder="alert"]'),
                	content: this.container.find('[data-placeholder="content"]')
                };
            }
        },

        // Render a waiting icon while.
        // This is typically done before getCurrentState which might be doing a time consuming ajax call
        // to fetch data.
        // NB depends on assets.
        renderWaitingView: { 
            value: function () {
                this.places.content.html('<img src="assets/img/ajax-loader.gif"></img>');
            }
        },
        
        loadCSS: {
          value: function () {
            var link = document.createElement("link");
            link.type = "text/css";
            link.rel = "stylesheet";
            link.href = '/src/widgets/social/' + this.widgetName + '/style.css';
            document.getElementsByTagName("head")[0].appendChild(link);
          }
        },
        
        renderMessages: {
            value: function () {
                if (this.places.alert) {
                    this.places.alert.empty();
                    for (var i=0; i<this.messages.length; i++) {
                        var message = this.messages[i];
                        var alertClass = 'default';
                        switch (message.type) {
                            case 'success': alertClass = 'success';break;
                            case 'info': alertClass = 'info'; break;
                            case 'warning': alertClass = 'warning';break;
                            case 'danger':
                            case 'error': alertClass = 'danger'; break; 
                        }
                        this.places.alert.append(
                        '<div class="alert alert-dismissible alert-'+alertClass+'" role="alert">' +
                        '<button type="button" class="close" data-dismiss="alert"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>' +
                        '<strong>' + message.title + '</strong> ' + message.message + '</div>');
                    }
                }
            }
        },

        clearMessages: {
            value: function() {
                this.messages = [];
                this.renderMessages();
            }
        },

        addSuccessMessage: {
            value: function(title, message) {
              if (message === undefined) {
                message = title;
                title = '';
              }
                this.messages.push({
                    type: 'success', title: title, message: message
                });
                this.renderMessages();
            }
        }, 
        
        addWarningMessage: {
            value: function(title, message) {
              if (message === undefined) {
                message = title;
                title = '';
              }
                this.messages.push({
                    type: 'warning', title: title, message: message
                });
                this.renderMessages();
            }
        },

        addErrorMessage: {
            value: function(title, message) {
              if (message === undefined) {
                message = title;
                title = '';
              }
                this.messages.push({
                    type: 'error', title: title, message: message
                });
                this.renderMessages();
            }
        },
        
        makeWorkspaceObjectId: {
          value: function (workspaceId, objectId) {
            return 'ws.' + workspaceId + '.obj.' + objectId;
          }
        },
        
        // KBase Service Utility Methods
        // NB: these should really be contained in the service apis, but those are automatically generated.
        // Maybe a kbase services utility module?
        workspace_metadata_to_object: {
          value: function(wsInfo) {
    				return {
    					id: wsInfo[0],
    					name: wsInfo[1],
    					owner: wsInfo[2],
    					moddate: wsInfo[3],
    					object_count: wsInfo[4],
    					user_permission: wsInfo[5],
    					globalread: wsInfo[6],
    					lockstat: wsInfo[7],
    					metadata: wsInfo[8]
    				};
          }
        },
        
        narrative_info_to_object: {
          value: function (data) {
    				return {
    					id: data[0],
    					name: data[1],
    					type: data[2],
    					save_date: data[3],
    					version: data[4],
    					saved_by: data[5],
    					wsid: data[6],
    					ws: data[7],
    					checksum: data[8],
    					size: data[9],
    					metadata: data[10],
    					ref: data[7] + '/' + data[1],
    					obj_id: 'ws.' + data[6] + '.obj.' + data[0]
    				};
          }
        }

    });

    return SocialWidget;
});